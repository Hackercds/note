# 接口测试与性能测试实战指导文档


## 一、接口测试（基于Postman）


### 1. 测试准备
#### 1.1 环境配置
- **工具安装**：下载Postman客户端（[官网](https://www.postman.com/)），建议安装Postman Interceptor插件（用于本地文件读取、Cookie同步）。
- **工作区设置**：新建`接口测试工作区`，创建Collection（按模块划分，如“用户模块”“订单模块”），便于批量管理接口。
- **环境变量配置**：  
  1. 点击左侧`Environments`→`+`新建环境（如“测试环境”“生产环境”）；  
  2. 添加全局变量（如`baseUrl: https://api.test.com`），请求中用`{{baseUrl}}`引用，避免重复修改URL。


### 2. 核心操作流程
#### 2.1 单接口测试配置（以RESTful API为例）
| 步骤 | 操作细节 | 示例 |
|------|----------|------|
| 1. 创建请求 | 右键Collection→`Add Request`，填写名称（如“用户登录”） | - |
| 2. 配置请求信息 | - 方法：选择`POST`（登录通常为POST）；<br>- URL：`{{baseUrl}}/user/login`；<br>- Headers：添加`Content-Type: application/json`；<br>- Body：选`raw→JSON`，填写请求体 | 请求体：<br>`{"username": "test","password": "123456"}` |
| 3. 发送请求 | 点击`Send`，查看响应（Status Code、Body、Headers） | 响应体：<br>`{"code":200,"data":{"token":"xxx"}}` |


#### 2.2 断言脚本（Tests标签页）
**核心断言场景及代码**：
```javascript
// 1. 验证状态码（基础必选）
pm.test("状态码为200", () => pm.response.to.have.status(200));

// 2. 验证响应时间（性能预判断）
pm.test("响应时间<500ms", () => pm.expect(pm.response.responseTime).lt(500));

// 3. 解析JSON响应并验证字段（多层嵌套场景）
const res = pm.response.json();
pm.test("登录成功返回token", () => {
  pm.expect(res.code).to.eql(200); // 业务码验证
  pm.expect(res.data).to.have.property("token"); // 检查字段存在
  pm.expect(res.data.token).to.not.be.empty; // 字段非空
});

// 4. 验证响应头
pm.test("返回JSON格式", () => {
  pm.expect(pm.response.headers.get("Content-Type")).to.include("application/json");
});
```


#### 2.3 变量提取与接口关联（解决依赖）
**场景**：登录接口返回的`token`需作为后续接口的请求头参数。  
**步骤**：  
1. 在登录接口的`Tests`中提取`token`：  
   ```javascript
   const res = pm.response.json();
   pm.environment.set("authToken", res.data.token); // 存入环境变量
   ```  
2. 后续接口（如“获取用户信息”）的`Headers`中引用：  
   `Authorization: Bearer {{authToken}}`  


#### 2.4 批量执行与数据驱动（Collection Runner）
**场景**：用多组测试数据验证同一接口（如不同账号登录）。  
**步骤**：  
1. 准备JSON测试数据（`login-data.json`）：  
   ```json
   [
     {"username": "validUser", "password": "123", "expectCode": 200},
     {"username": "invalidUser", "password": "456", "expectCode": 401}
   ]
   ```  
2. 打开`Collection Runner`（点击Collection右侧`...→Run`）：  
   - 选择环境、迭代次数（与数据行数一致）；  
   - `Data`栏上传`login-data.json`；  
3. 请求体与断言中引用数据：  
   - 请求体：`{"username": "{{username}}", "password": "{{password}}"}`；  
   - 断言：`pm.expect(pm.response.code).to.eql(pm.iterationData.get("expectCode"))`；  
4. 点击`Run`，查看汇总报告（通过率、响应时间分布）。  


#### 2.5 复杂JSON处理技巧
**场景**：响应包含数组或多层嵌套（如列表查询接口）。  
**示例响应**：  
```json
{
  "code": 200,
  "data": {
    "list": [{"id": 1, "name": "商品A"}, {"id": 2, "name": "商品B"}],
    "total": 2
  }
}
```  
**解析脚本**：  
```javascript
const res = pm.response.json();
// 验证数组长度与total一致
pm.test("列表总数正确", () => {
  pm.expect(res.data.list.length).to.eql(res.data.total);
});
// 遍历数组验证每个元素
res.data.list.forEach(item => {
  pm.test(`商品${item.id}名称非空`, () => {
    pm.expect(item.name).to.not.be.empty;
  });
});
// 提取第一个商品ID
pm.environment.set("firstGoodsId", res.data.list[0].id);
```


### 3. 高级技巧
- **本地JSON文件作为请求体**：通过前置脚本读取本地模板并动态修改：  
  ```javascript
  // Pre-request Script
  const fs = require('fs');
  const template = JSON.parse(fs.readFileSync('order-template.json', 'utf8'));
  template.timestamp = new Date().getTime(); // 动态添加时间戳
  pm.request.body.raw = JSON.stringify(template);
  ```  
- **接口文档自动生成**：写完断言后，点击`Collection→Generate Documentation`，生成含测试用例的HTML文档。  


## 二、性能测试（基于JMeter）


### 1. 测试准备
#### 1.1 工具安装与环境配置
- **安装**：下载JMeter（[官网](https://jmeter.apache.org/)），需Java 8+环境；  
- **插件安装**：打开`bin/jmeter.bat`→`Options→Plugins Manager`，安装：  
  - `Stepping Thread Group`（阶梯加压）；  
  - `JSON Extractor`（JSON响应提取）；  
  - `HTML Reporting Dashboard`（HTML报告生成）。  


### 2. 核心操作流程
#### 2.1 测试计划创建（基础框架）
1. 新建测试计划→右键添加`线程组`（控制并发用户）；  
2. 线程组配置（以100并发为例）：  
   - 线程数：100（模拟100个用户）；  
   - Ramp-Up时间：10s（10秒内启动所有线程，避免瞬间冲击）；  
   - 循环次数：10（每个用户发送10次请求，总请求数=100×10=1000）。  


#### 2.2 HTTP请求配置（以接口压测为例）
1. 右键线程组→`Add→Sampler→HTTP请求`：  
   - 服务器名称：`api.test.com`（或填IP）；  
   - 端口号：80（HTTPS为443）；  
   - 方法：`POST`；  
   - 路径：`/user/login`；  
   - 消息体数据：`{"username": "${user}", "password": "${pwd}"}`（`${}`为变量占位符）。  


#### 2.3 参数化（多用户数据模拟）
**方式1：CSV文件参数化（推荐）**  
1. 准备`users.csv`（第一行为变量名）：  
   ```
   user,pwd
   test1,123
   test2,456
   ```  
2. 右键线程组→`Add→配置元件→CSV Data Set Config`：  
   - 文件名：`users.csv`（绝对路径或相对路径）；  
   - 变量名称：`user,pwd`（与CSV表头一致）；  
   - 忽略首行：`True`；  
   - 循环读取：`True`（数据不足时循环使用）。  


#### 2.4 响应提取与关联（如token传递）
1. 右键登录请求→`Add→后置处理器→JSON Extractor`：  
   - 引用名称：`token`（后续用`${token}`引用）；  
   - JSON路径表达式：`$.data.token`（根据实际响应调整）；  
   - 匹配数字：`0`（取第一个匹配值）。  
2. 后续请求的`HTTP信息头管理器`中添加：  
   `Authorization: Bearer ${token}`  


#### 2.5 断言配置（验证响应正确性）
1. 右键HTTP请求→`Add→断言→响应断言`：  
   - 应用范围：`Main sample only`；  
   - 测试字段：`响应文本`；  
   - 模式匹配规则：`包含`；  
   - 模式：`"code":200`（验证业务成功）。  


#### 2.6 监听器配置（结果分析）
| 监听器名称 | 核心指标 | 用途 |
|------------|----------|------|
| 聚合报告 | 样本数、平均值、90% Line、吞吐量（TPS）、错误率 | 整体性能评估 |
| 响应时间曲线图 | 响应时间随时间变化趋势 | 观察性能拐点 |
| TPS曲线图 | 每秒处理请求数变化 | 判断系统承载上限 |
| 查看结果树 | 单条请求的请求/响应详情 | 调试脚本错误 |  


#### 2.7 非GUI模式执行（压测必用）
**命令格式**：  
```bash
jmeter -n -t test.jmx -l result.jtl -e -o report_dir -j run.log
```  
| 参数 | 作用 |
|------|------|
| `-n` | 启用非GUI模式（节省资源，适合高并发） |
| `-t test.jmx` | 指定测试计划文件（从GUI界面保存生成） |
| `-l result.jtl` | 生成结果文件（可导入GUI查看详情） |
| `-e -o report_dir` | 自动生成HTML报告（`report_dir`需为空目录） |
| `-j run.log` | 记录运行日志（排查脚本错误） |  


### 3. 高级场景设计
#### 3.1 阶梯加压（模拟用户增长）
1. 右键线程组→`Add→Threads (Users)→Stepping Thread Group`：  
   - 初始线程数：0；  
   - 启动线程数：50（每次增加50用户）；  
   - 每批启动间隔：60s（每60秒增加一批）；  
   - 总线程数：200（最终达到200并发）；  
   - 持续时间：300s（稳定运行5分钟）。  


#### 3.2 分布式压测（突破单机器限制）
**场景**：并发数超过1000时，单台压测机性能不足。  
**步骤**：  
1. **负载机配置**：  
   - 多台机器安装相同版本JMeter；  
   - 负载机启动服务：`jmeter-server -Dserver_port=1099`（Windows用`jmeter-server.bat`）。  
2. **主控机配置**：  
   - 编辑`bin/jmeter.properties`：`remote_hosts=负载机1IP:1099,负载机2IP:1099`；  
   - GUI中点击`Run→Remote Start All`，或非GUI命令：`jmeter -n -t test.jmx -R 负载机1IP,负载机2IP`。  


#### 3.3 性能瓶颈判断依据
| 指标 | 阈值 | 可能原因 |
|------|------|----------|
| 错误率 | >0.1% | 服务器过载、接口异常 |
| 响应时间（90% Line） | >1000ms | 代码效率低、数据库慢查询 |
| TPS | 增长停滞/下降 | CPU/内存/带宽达到瓶颈 |


## 三、测试流程与规范
1. **接口测试流程**：  
   需求分析→用例设计（覆盖正常/异常场景）→Postman脚本编写→批量执行→缺陷提交→回归测试。  
2. **性能测试流程**：  
   性能需求确认（如TPS≥500、响应时间<500ms）→测试计划设计→JMeter脚本开发→场景执行→结果分析→优化建议。  
3. **文档输出**：  
   - 接口测试：《接口测试用例》《测试报告》（含通过率、缺陷统计）；  
   - 性能测试：《性能测试报告》（含压测场景、指标数据、瓶颈分析、优化方案）。  


## 四、常见问题解决
| 问题 | 解决方案 |
|------|----------|
| Postman断言失败但响应正确 | 检查JSON路径是否错误（如多层嵌套漏写层级） |
| JMeter变量引用无效 | 确保变量提取器与引用请求在同一线程组，且引用名称正确 |
| 压测时TPS上不去 | 检查压测机CPU/内存是否过载（改用分布式压测）；排查服务器资源瓶颈 |
| Postman批量执行数据不生效 | 确认数据文件格式正确（JSON数组），且迭代次数与数据行数一致 |


通过以上内容，可系统掌握接口测试（Postman）和性能测试（JMeter）的核心操作，覆盖从基础配置到高级场景的全流程，满足企业级测试需求。